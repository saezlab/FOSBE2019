0.9+0.8+0.8+0.7
3.2/4
0.8+0.33
1.13/0.33
1.13/1.33
0.2+0.15+0.1+0.1
0.55/4
0.1375+0.5
0.6375/1.5
load(file = "~/Desktop/Ariel-Final/Project-15/PHONEMeS/PHONEMeS/PHONEMeS_01_10%/resList_1.RData")
resList[[1]]
314-245
kk = resList[[1]][[2]]
View(kk)
nrow(resList[[1]][[1]])
nrow(resList[[1]][[2]])
kk1 = resList[[1]][[1]]
kk2 = resList[[1]][[2]]
View(kk1)
View(kk2)
252-245
load(file = "~/Desktop/Ariel-Final/Project-15/PHONEMeS/PHONEMeS/PHONEMeS_01_10%/resList_1.RData")
rm(list = ls())
load(file = "~/Desktop/Ariel-Final/Project-15/PHONEMeS/PHONEMeS/PHONEMeS_01_10%/resList_1.RData")
kk1 resList[[40]][[1]]
kk1 <- resList[[40]][[1]]
kk2 <- resList[[40]][[2]]
256-247
View(kk2)
idx = c()
for(ii in 1:nrow(kk2)){if(length(intersect(which(kk1[,1]==kk2[ii, 1]), which(kk1[, 3]==kk2[ii, 3])))==0{idx=c(idx, ii)})}
idx
idx = c()
for(ii in 1:nrow(kk2)){if(length(intersect(which(kk1[,1]==kk2[ii, 1]), which(kk1[, 3]==kk2[ii, 3])))==0){idx=c(idx, ii)}}
idx
kk2[idx, ]
load(file = "~/Desktop/Ariel-Final/Project-15/Prepare-Data/cnolist.RData")
kk2[idx, ]
plotCNOlist(CNOlist = cnolist)
which(colnames(cnolist@signals$`0`)=="STAT3_S727")
ncol(cnolist@signals$`0`)
which(colnames(cnolist@signals$`0`)=="GSK3B_Y216")
which(colnames(cnolist@signals$`0`)=="RB1_T821")
load(file = "~/Desktop/Ariel-Final/Project-15/PHONEMeS/Build-BN-PKN/dataInput_pval_01_fc_10%.RData")
dataInput$resFC$RB1_T821
dataInput$resFC$RB1_T821
kk2[idx, ]
dataInput$resFC$STAT3_S727
which(colnames(cnolist@signals$`0`)=="STAT3_S727")
ncol(cnolist@signals$`0`)
dev.off()
load(file = "~/Desktop/Ariel-Final/Project-15/PHONEMeS/PHONEMeS/PHONEMeS_005_50%/resList_1.RData")
kk1 = resList[[1]][[1]]
kk2 = resList[[1]][[2]]
idx = c()
for(ii in 1:nrow(kk2)){if(length(intersect(x = which(kk1[,1]==kk2[ii,1]), y = which(kk1[,3]==kk2[ii,3])))==0){idx=c(idx,ii)}}
idx
kk2[idx, ]
rm(list = ls())
load(file = "~/Desktop/Ariel-Final/Project-15/PHONEMeS/PHONEMeS/PHONEMeS_005_50%/resList_1.RData")
kk1 = resList[[1]][[1]]
kk2 = resList[[1]][[2]]
idx = c()
for(ii in 1:nrow(kk2)){if(length(intersect(x = which(kk1[,1]==kk2[ii,1]), y = which(kk1[,3]==kk2[ii,3])))==0){idx=c(idx,ii)}}
idx
kk2[idx, ]
runif(n = 10, min = 1, max = 10000)
round(runif(n = 10, min = 1, max = 10000))
c(1690, 1467, 4237, 6188, 4752, 9308, 8693, 6533, 5186, 9726)
seeds = c(1690, 1467, 4237, 6188, 4752, 9308, 8693, 6533, 5186, 9726)
runif(n = 10, min = 1, max = 10000)
round(runif(n = 10, min = 1, max = 10000))
seeds = c(4651, 2361, 5206,  746, 5331, 8304, 6516, 5135, 9877, 9264)
library(CNORfeeder)
data(CNOlistDREAM,package="CellNOptR")
data(DreamModel,package="CellNOptR")
BTable <- makeBTables(CNOlist=CNOlistDREAM, k=2, measErr=c(0.1, 0))
BTable
Lrank <- linksRanking(CNOlist=CNOlistDREAM, measErr=c(0.1, 0), savefile=FALSE)
model<-preprocessing(data=CNOlistDREAM, model=DreamModel)
modelIntegr <- mapBTables2model(BTable=BTable,model=model,allInter=TRUE)
modelIntegr$reacID[modelIntegr$indexIntegr]
plotModel(model=modelIntegr, CNOlist=CNOlistDREAM, indexIntegr=modelIntegr$indexIntegr)
data(PPINigraph,package="CNORfeeder")
PPINigraph
PPINigraph[[1]]
PPINigraph[[2]]
PPINigraph[[3]]
PPINigraph[[4]]
PPINigraph[[5]]
PPINigraph[[6]]
?PPINigraph
data(UniprotIDdream,package="CNORfeeder")
modelIntegrWeight <- weighting(modelIntegr=modelIntegr, PKNmodel=DreamModel,
CNOlist=CNOlistDREAM, integrFac=10,
UniprotID=UniprotIDdream, PPI=PPINigraph)
library(devtools)
library(devtools)
devtools::install_github("davismcc/scater", build_vignettes = TRUE,ref = "RELEASE_3_6")
devtools::install_github("MarioniLab/scran", ref="RELEASE_3_6")
version
library(scater)
setwd("~/Desktop/Feeder_Dev/Feeder-Analysis/")
library(CellNOptR)
library(MEIGOR)
library(CNORode)
library(doParallel)
library(readr)
library(infotheo)
library(igraph)
load(file = "../Data/cnolist.RData")
load(file = "../Data/model.RData")
load(file = "../Data/database.RData")
load(file = "../Results/Best-Solutions/simData_initial.RData")
source("../Public/computeMSE.R")
source("../Public/computeMI.R")
source("../Public/runDynamicFeeder.R")
source("../Public/buildFeederObjectDynamic.R")
source("../Public/identifyMisfitIndices.R")
source("../Public/map2cys.R")
source("../Public/integrateLinks.R")
source("../Public/preprocessingWeighted.R")
indices <- identifyMisfitIndices(cnolist = cnolist, model = model, simData = simData, mseThresh = 0.05168124) # 0.05168124 = 5% error threshold
object <- buildFeederObjectDynamic(model = model, cnolist = cnolist, database = database, indices = indices, pathLength = 4)
integratedModel = integrateLinks(feederObject = object, cnolist = cnolist, compression = TRUE, expansion = FALSE, database = database)
plotModel(model = integratedModel$model, CNOlist = cnolist, indexIntegr = integratedModel$integLinksIdx)
paramsSSm=defaultParametersSSm()
paramsSSm$local_solver = "DHC"
paramsSSm$maxtime = 15000;
paramsSSm$maxeval = Inf;
paramsSSm$atol=1e-6;
paramsSSm$reltol=1e-6;
paramsSSm$nan_fac=1000;
paramsSSm$dim_refset=30;
paramsSSm$n_diverse=1000;
paramsSSm$maxStepSize=Inf;
paramsSSm$maxNumSteps=10000;
paramsSSm$transfer_function = 4;
paramsSSm$lambda_tau=0.1
paramsSSm$lambda_k=0.01
paramsSSm$bootstrap=F
paramsSSm$SSpenalty_fac=10
paramsSSm$SScontrolPenalty_fac=10
set.seed(4381)
ode_parameters=createLBodeContPars(integratedModel$model, LB_n = 1, LB_k = 0,
LB_tau = 0, UB_n = 3, UB_k = 1, UB_tau = 1, default_n = 3,
default_k = 0.5, default_tau = 0.01, opt_n = FALSE, opt_k = TRUE,
opt_tau = TRUE, random = TRUE)
penFactor_k = 10
penFactor_tau = 5
weightFactor = 0
model = integratedModel$model
reacDiff = model$reacID[integratedModel$integLinksIdx]
speciesDiff = model$namesSpecies[integratedModel$integSpeciesIdx]
lambda_tau = rep(paramsSSm$lambda_tau, length(ode_parameters$index_tau))
for(ii in 1:length(ode_parameters$index_tau)){
if(ode_parameters$parNames[ode_parameters$index_tau[ii]]%in%paste0("tau_", speciesDiff)){
lambda_tau[ii] = lambda_tau[ii]*penFactor_tau
}
}
paramsSSm$lambda_tau = lambda_tau
lambda_k = rep(paramsSSm$lambda_k, length(ode_parameters$index_k))
ll = strsplit(x = reacDiff, split = "=", fixed = TRUE)
ss = unlist(lapply(ll, function(ll) ll[[1]]))
ss = gsub(pattern = "!", replacement = "", x = ss, fixed = TRUE)
tt = unlist(lapply(ll, function(ll) ll[[2]]))
reactions = paste0(ss, "_k_", tt)
for(ii in 1:length(ode_parameters$index_k)){
if(ode_parameters$parNames[ode_parameters$index_k[ii]]%in%reactions){
ss = strsplit(x = ode_parameters$parNames[ode_parameters$index_k[ii]], split = "_k_", fixed = TRUE)[[1]][1]
tt = strsplit(x = ode_parameters$parNames[ode_parameters$index_k[ii]], split = "_k_", fixed = TRUE)[[1]][2]
idx = which(model$reacID%in%c(paste0(ss, "=", tt), paste0("!", ss, "=", tt)))[1]
lambda_k[ii] = lambda_k[ii]*penFactor_k + integratedModel$databasePenalty[idx]*weightFactor
}
}
lambda_k
penFactor_k = 500
model = integratedModel$model
reacDiff = model$reacID[integratedModel$integLinksIdx]
speciesDiff = model$namesSpecies[integratedModel$integSpeciesIdx]
lambda_tau = rep(paramsSSm$lambda_tau, length(ode_parameters$index_tau))
for(ii in 1:length(ode_parameters$index_tau)){
if(ode_parameters$parNames[ode_parameters$index_tau[ii]]%in%paste0("tau_", speciesDiff)){
lambda_tau[ii] = lambda_tau[ii]*penFactor_tau
}
}
paramsSSm$lambda_tau = lambda_tau
lambda_k = rep(paramsSSm$lambda_k, length(ode_parameters$index_k))
ll = strsplit(x = reacDiff, split = "=", fixed = TRUE)
ss = unlist(lapply(ll, function(ll) ll[[1]]))
ss = gsub(pattern = "!", replacement = "", x = ss, fixed = TRUE)
tt = unlist(lapply(ll, function(ll) ll[[2]]))
reactions = paste0(ss, "_k_", tt)
for(ii in 1:length(ode_parameters$index_k)){
if(ode_parameters$parNames[ode_parameters$index_k[ii]]%in%reactions){
ss = strsplit(x = ode_parameters$parNames[ode_parameters$index_k[ii]], split = "_k_", fixed = TRUE)[[1]][1]
tt = strsplit(x = ode_parameters$parNames[ode_parameters$index_k[ii]], split = "_k_", fixed = TRUE)[[1]][2]
idx = which(model$reacID%in%c(paste0(ss, "=", tt), paste0("!", ss, "=", tt)))[1]
lambda_k[ii] = lambda_k[ii]*penFactor_k + integratedModel$databasePenalty[idx]*weightFactor
}
}
paramsSSm$lambda_k = lambda_k
lambda_k
if (class(cnolist)=="CNOlist"){cnolist = compatCNOlist(cnolist)}
checkSignals(CNOlist=cnolist,model=model)
adjMat=incidence2Adjacency(model);
if(is.null(ode_parameters)){
ode_parameters=createLBodeContPars(model,random=TRUE);
}
if(is.null(indices))indices <- indexFinder(cnolist,model,verbose=FALSE);
dummy_f<-function(x){
return(0);
}
problem<-list(f=dummy_f,x_L=rep(0),x_U=c(1));
opts<-list();
opts$maxeval=0;
opts$maxtime=0;
val=essR(problem,opts)
problem=list();
adjMatrix=incidence2Adjacency(model);
if(is.null(indices))indices=indexFinder(cnolist,model,verbose=FALSE);
sim_function=getLBodeSimFunction(cnolist,model,adjMatrix1=adjMatrix,
indices1=indices, odeParameters1=ode_parameters$parValues, time1=time,verbose1=verbose,
transfer_function1=transfer_function,reltol1=reltol,atol1=atol,maxStepSize1=maxStepSize,
maxNumSteps1=maxNumSteps,maxErrTestsFails1=maxErrTestsFails)
sim_function()
sim_function
ode_parameters1$parValues[ode_parameters1$index_opt_pars]=x;
ode_parameters1$parValues[ode_parameters1$index_opt_pars]
ode_parameters1=ode_parameters
ode_parameters1$parValues[ode_parameters1$index_opt_pars]
x=ode_parameters1$parValues[ode_parameters1$index_opt_pars]
sim=sim_function1(cnolist1,model1,ode_parameters1$parValues);
library(CNORode)
sim=sim_function1(cnolist1,model1,ode_parameters1$parValues);
sim_function1=sim_function
sim=sim_function1(cnolist1,model1,ode_parameters1$parValues);
model1=model
cnolist1=cnolist
sim=sim_function1(cnolist1,model1,ode_parameters1$parValues);
verbose=TRUE
sim=sim_function1(cnolist1,model1,ode_parameters1$parValues);
(sum(abs(ode_parameters1$parValues[ode_parameters1$index_k])))
lambda_k*(sum(abs(ode_parameters1$parValues[ode_parameters1$index_k])))
lambda_k
L1reg_k<-lambda_k*(sum(abs(ode_parameters1$parValues[ode_parameters1$index_k])))
L1reg_tau<-lambda_tau*(sum(abs(ode_parameters1$parValues[ode_parameters1$index_tau])))
L1reg<-L1reg_k+L1reg_tau
L1reg<-sum(L1reg_k)+sum(L1reg_tau)
L1reg
abs(ode_parameters1$parValues[ode_parameters1$index_k])
getwd()
rm(list = ls())
getwd()
setwd("/Users/enio.gjerga/Desktop/Feeder_Dev/ToyExample/")
library(CellNOptR)
library(MEIGOR)
library(CNORode)
library(doParallel)
library(readr)
library(infotheo)
library(igraph)
# Sourcing all the Dynamic-Feeder functions needed
source("../Public/computeMSE.R")
source("../Public/computeMI.R")
source("../Public/runDynamicFeeder.R")
source("../Public/buildFeederObjectDynamic.R")
source("../Public/identifyMisfitIndices.R")
source("../Public/map2cys.R")
source("../Public/integrateLinks.R")
source("../Public/preprocessingWeighted.R")
source("../Public/getLBodeContObjFunctionWeighted.R")
source("../Public/parEstimationLBodeSSmWeighted.R")
source("../Public/parEstimationLBodeWeighted.R")
# loading the toy example
data("ToyModel", package="CellNOptR")
data("CNOlistToy", package="CellNOptR")
model = ToyModel
cnolist = CNOlist(CNOlistToy)
# set initial parameters (here parameters 'k' and 'tau' are optimised and 'n' fixed to 3)
ode_parameters=createLBodeContPars(model, LB_n = 1, LB_k = 0,
LB_tau = 0, UB_n = 3, UB_k = 1, UB_tau = 1, default_n = 3,
default_k = 0.5, default_tau = 0.01, opt_n = FALSE, opt_k = TRUE,
opt_tau = TRUE, random = TRUE)
## Parameter Optimization
# essm
paramsSSm=defaultParametersSSm()
paramsSSm$local_solver = "DHC"
paramsSSm$maxtime = 60;
paramsSSm$maxeval = Inf;
paramsSSm$atol=1e-6;
paramsSSm$reltol=1e-6;
paramsSSm$nan_fac=1000;
paramsSSm$dim_refset=30;
paramsSSm$n_diverse=1000;
paramsSSm$maxStepSize=Inf;
paramsSSm$maxNumSteps=10000;
paramsSSm$transfer_function = 4;
paramsSSm$lambda_tau=0.1
paramsSSm$lambda_k=0.01
paramsSSm$bootstrap=F
paramsSSm$SSpenalty_fac=0
paramsSSm$SScontrolPenalty_fac=0
## Training of the initial model
opt_pars=parEstimationLBode(cnolist, model, method="essm", ode_parameters=ode_parameters, paramsSSm=paramsSSm)
simData = plotLBodeFitness(cnolist = cnolist, model = model, ode_parameters = opt_pars, transfer_function = 4)
## Loading interactions from Omnipath
database <- read_delim("omnipathDB.txt", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
database <- as.matrix(database)
## Identifying the mis-fits (measurements with mse worse than 0.05) and interactions from the database which we want to integrate
indices = identifyMisfitIndices(cnolist = cnolist, model = model, simData = simData, mseThresh = 0.05)
feederObject = buildFeederObjectDynamic(model = model, cnolist = cnolist, indices = indices, database = database, pathLength = 2)
integratedModel = integrateLinks(feederObject = feederObject, cnolist = cnolist, compression = FALSE, expansion = FALSE, database = database)
## Plotting the integrated model by highlighting in purple the new added links to the PKN
plotModel(model = integratedModel$model, CNOlist = cnolist, indexIntegr = integratedModel$integLinksIdx)
## Optimizing the integrated model and plotting the improved fits
ode_parameters=createLBodeContPars(integratedModel$model, LB_n = 1, LB_k = 0,
LB_tau = 0, UB_n = 3, UB_k = 1, UB_tau = 1, default_n = 3,
default_k = 0.5, default_tau = 0.01, opt_n = FALSE, opt_k = TRUE,
opt_tau = TRUE, random = TRUE)
res = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel, ode_parameters = ode_parameters, paramsSSm = paramsSSm, penFactor_k = 1)
plotLBodeFitness(cnolist = res$CNOList, model = res$`Integrated-Model`, ode_parameters = res$Parameters, transfer_function = 4)
plotLBodeFitness(cnolist = res$CNOList, model = res$`Integrated-Model`$model, ode_parameters = res$Parameters, transfer_function = 4)
dev.off()
res = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel, ode_parameters = ode_parameters, paramsSSm = paramsSSm, penFactor_k = 1000000)
plotLBodeFitness(cnolist = res$CNOList, model = res$`Integrated-Model`$model, ode_parameters = res$Parameters, transfer_function = 4)
dev.off()
rm(list = ls())
getwd()
15000/3600
source.all("../Public/", grepstring="\\.R",  print.source=TRUE, file_sep="__"  )
files.sources = list.files("../Public/")
sapply(files.sources, source)
sapply(paste0("../Public/", files.sources), source)
files.sources = list.files(path = "../Public/", pattern = ".R")
sapply(paste0("../Public/", files.sources), source)
rm(list = ls())
files.sources = list.files(path = "../Public/", pattern = ".R")
sapply(paste0("../Public/", files.sources), source)
files.sources = list.files(path = "../Public/", pattern = "*.R")
sapply(paste0("../Public/", files.sources), source)
sapply(paste0("../Public/", files.sources), source, .GlobalEnv)
install.packages(Jmisc)
rom(list=ls())
rm(list = ls())
library(R.utils)
sourceDirectory("../Public/")
sourceDirectory("../Public/")
sourceDirectory("../Public/")
rm(list = ls())
sourceDirectory("../Public/")
sourceDirectory("../Public/")
sourceDirectory("../Public/")
for (f in list.files(path = "../Public/", pattern="*.R")) {
source(f)
}
for (f in list.files(path = "../Public", pattern="*.R")) {
source(f)
}
getwd()
rm(list = ls())
pathnames <- list.files(pattern="[.]R$", path="../Results/", full.names=TRUE)
pathnames <- list.files(pattern="[.]R$", path="../Public/", full.names=TRUE)
pathnames <- list.files(pattern="[.]R$", path="../Public", full.names=TRUE)
sapply(pathnames, FUN=source)
sapply(list.files(pattern="[.]R$", path="../Public", full.names=TRUE), source)
rm(list = ls())
sapply(list.files(pattern="[.]R$", path="../Public", full.names=TRUE), source)
rm(list = ls())
library(CellNOptR)
library(MEIGOR)
library(CNORode)
library(doParallel)
library(readr)
library(infotheo)
library(igraph)
# Sourcing all the Dynamic-Feeder functions needed
# source("../Public/computeMSE.R")
# source("../Public/computeMI.R")
# source("../Public/runDynamicFeeder.R")
# source("../Public/buildFeederObjectDynamic.R")
# source("../Public/identifyMisfitIndices.R")
# source("../Public/map2cys.R")
# source("../Public/integrateLinks.R")
# source("../Public/preprocessingWeighted.R")
# source("../Public/getLBodeContObjFunctionWeighted.R")
# source("../Public/parEstimationLBodeSSmWeighted.R")
# source("../Public/parEstimationLBodeWeighted.R")
sapply(list.files(pattern="[.]R$", path="../Public", full.names=TRUE), source)
# loading the toy example
data("ToyModel", package="CellNOptR")
data("CNOlistToy", package="CellNOptR")
model = ToyModel
cnolist = CNOlist(CNOlistToy)
# set initial parameters (here parameters 'k' and 'tau' are optimised and 'n' fixed to 3)
ode_parameters=createLBodeContPars(model, LB_n = 1, LB_k = 0,
LB_tau = 0, UB_n = 3, UB_k = 1, UB_tau = 1, default_n = 3,
default_k = 0.5, default_tau = 0.01, opt_n = FALSE, opt_k = TRUE,
opt_tau = TRUE, random = TRUE)
## Parameter Optimization
# essm
paramsSSm=defaultParametersSSm()
paramsSSm$local_solver = "DHC"
paramsSSm$maxtime = 60;
paramsSSm$maxeval = Inf;
paramsSSm$atol=1e-6;
paramsSSm$reltol=1e-6;
paramsSSm$nan_fac=1000;
paramsSSm$dim_refset=30;
paramsSSm$n_diverse=1000;
paramsSSm$maxStepSize=Inf;
paramsSSm$maxNumSteps=10000;
paramsSSm$transfer_function = 4;
paramsSSm$lambda_tau=0.1
paramsSSm$lambda_k=0.01
paramsSSm$bootstrap=F
paramsSSm$SSpenalty_fac=0
paramsSSm$SScontrolPenalty_fac=0
## Training of the initial model
opt_pars=parEstimationLBode(cnolist, model, method="essm", ode_parameters=ode_parameters, paramsSSm=paramsSSm)
simData = plotLBodeFitness(cnolist = cnolist, model = model, ode_parameters = opt_pars, transfer_function = 4)
## Loading interactions from Omnipath
database <- read_delim("omnipathDB.txt", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
database <- as.matrix(database)
## Identifying the mis-fits (measurements with mse worse than 0.05) and interactions from the database which we want to integrate
indices = identifyMisfitIndices(cnolist = cnolist, model = model, simData = simData, mseThresh = 0.05)
feederObject = buildFeederObjectDynamic(model = model, cnolist = cnolist, indices = indices, database = database, pathLength = 2)
integratedModel = integrateLinks(feederObject = feederObject, cnolist = cnolist, compression = FALSE, expansion = FALSE, database = database)
## Plotting the integrated model by highlighting in purple the new added links to the PKN
plotModel(model = integratedModel$model, CNOlist = cnolist, indexIntegr = integratedModel$integLinksIdx)
## Optimizing the integrated model and plotting the improved fits
ode_parameters=createLBodeContPars(integratedModel$model, LB_n = 1, LB_k = 0,
LB_tau = 0, UB_n = 3, UB_k = 1, UB_tau = 1, default_n = 3,
default_k = 0.5, default_tau = 0.01, opt_n = FALSE, opt_k = TRUE,
opt_tau = TRUE, random = TRUE)
## penalty factor of 2
res = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel, ode_parameters = ode_parameters, paramsSSm = paramsSSm, penFactor_k = 2)
plotLBodeFitness(cnolist = res$CNOList, model = res$`Integrated-Model`$model, ode_parameters = res$Parameters, transfer_function = 4)
res = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel, ode_parameters = ode_parameters, paramsSSm = paramsSSm, penFactor_k = 2)
plotLBodeFitness(cnolist = res$CNOList, model = res$`Integrated-Model`$model, ode_parameters = res$Parameters, transfer_function = 4)
dev.off()
res = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel, ode_parameters = ode_parameters, paramsSSm = paramsSSm, penFactor_k = 100)
plotLBodeFitness(cnolist = res$CNOList, model = res$`Integrated-Model`$model, ode_parameters = res$Parameters, transfer_function = 4)
dev.off()
res = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel, ode_parameters = ode_parameters, paramsSSm = paramsSSm, penFactor_k = 100000)
plotLBodeFitness(cnolist = res$CNOList, model = res$`Integrated-Model`$model, ode_parameters = res$Parameters, transfer_function = 4)
750/60
rm(list = ls())
error = c(0.05, 0.1, 0.2)
pL = c(1, 2, 3, 4, Inf)
penalty = c(1, 2, 5, 10, 50)
mm = matrix(data = , nrow = 1, ncol = 3)
for(ii in 1:length(error)){
for(jj in 1:length(pL)){
for(kk in 1:length(penalty)){
toBind = t(as.matrix(c(error[ii], pL[jj], penalty[kk])))
mm = rbind(mm, toBind)
}
}
}
mm = mm[-1, ]
nrow(mm)
9381,  829, 4912, 7192,
168, 5242, 4768, 6901, 4381, 5810, 6839, 3274, 9402, 2115,
6198, 4922, 5886, 6702, 8649, 1533, 4751, 1270, 8856, 9025,
253, 1933, 8813, 1791, 5354, 6794, 8909, 1305, 6059, 1888,
4805, 7859, 5224, 3198, 3378, 916, 6423, 5693, 9640, 2360,
1205, 6782, 8944, 8845
seeds = c(9381,  829, 4912, 7192,
168, 5242, 4768, 6901, 4381, 5810, 6839, 3274, 9402, 2115,
6198, 4922, 5886, 6702, 8649, 1533, 4751, 1270, 8856, 9025,
253, 1933, 8813, 1791, 5354, 6794, 8909, 1305, 6059, 1888,
4805, 7859, 5224, 3198, 3378, 916, 6423, 5693, 9640, 2360,
1205, 6782, 8944, 8845)
length(seeds)
round(runif(n = 75, min = 0, max = 10000))
seeds = c(7343, 6152, 7051, 3250, 3113, 71, 4375, 8049, 1675, 3485,
1257, 5509, 369, 2616, 8853, 6171, 3738, 5146, 4090, 5422,
4515, 9098, 2226, 9952, 8431, 748, 9324, 8943, 9750, 4010,
2845, 9541, 7643, 8477, 4827, 5191, 9398, 3500, 9895, 3527,
4311, 7, 87, 9716, 1750, 7967, 7198, 4836, 9538, 1612, 7412,
3465, 7183, 1791, 2684, 6658, 7915, 8133, 1136, 1999, 7346,
9549, 2713, 4689, 7304, 9419, 3267, 5710, 3529, 4500, 3194,
1322, 1448, 1416, 4915)
length(seeds)
error = c(0.05, 0.1, 0.2)
pL = c(1, 2, 3, 4, Inf)
penalty = c(1, 2, 5, 10, 50, 100)
mm = matrix(data = , nrow = 1, ncol = 3)
for(ii in 1:length(error)){
for(jj in 1:length(pL)){
for(kk in 1:length(penalty)){
toBind = t(as.matrix(c(error[ii], pL[jj], penalty[kk])))
mm = rbind(mm, toBind)
}
}
}
mm = mm[-1, ]
90-75
round(runif(n = 15, min = 0, max = 10000))
seeds = c(7343, 6152, 7051, 3250, 3113, 71, 4375, 8049, 1675, 3485,
1257, 5509, 369, 2616, 8853, 6171, 3738, 5146, 4090, 5422,
4515, 9098, 2226, 9952, 8431, 748, 9324, 8943, 9750, 4010,
2845, 9541, 7643, 8477, 4827, 5191, 9398, 3500, 9895, 3527,
4311, 7, 87, 9716, 1750, 7967, 7198, 4836, 9538, 1612, 7412,
3465, 7183, 1791, 2684, 6658, 7915, 8133, 1136, 1999, 7346,
9549, 2713, 4689, 7304, 9419, 3267, 5710, 3529, 4500, 3194,
1322, 1448, 1416, 4915, 913, 2725,  830,  173, 6695, 6181,
8838, 2382, 7050, 6271, 9517, 5652, 5452, 1270, 8091)
seeds
length(seeds)
900/60
